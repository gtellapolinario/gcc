name: Release

on:
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      target_sha:
        description: "Optional commit SHA to release (defaults to current workflow SHA)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read

jobs:
  publish-release:
    if: >-
      ${{
        github.event_name == 'workflow_dispatch' ||
        (
          github.event.pull_request.merged == true &&
          github.event.pull_request.base.ref == 'main' &&
          startsWith(github.event.pull_request.title, 'release:')
        )
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve release metadata
        id: metadata
        env:
          EVENT_NAME: ${{ github.event_name }}
          DISPATCH_TARGET_SHA: ${{ inputs.target_sha }}
          PR_MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
        run: |
          python - <<'PY'
          import os
          import re
          import subprocess
          import tomllib
          from pathlib import Path

          def git_show(commit_sha: str, path: str) -> str:
              return subprocess.check_output(
                  ["git", "show", f"{commit_sha}:{path}"],
                  text=True,
              )

          event_name = os.environ.get("EVENT_NAME", "").strip()
          dispatch_sha = os.environ.get("DISPATCH_TARGET_SHA", "").strip()
          pr_merge_sha = os.environ.get("PR_MERGE_SHA", "").strip()

          if event_name == "pull_request":
              target_sha = pr_merge_sha
          else:
              target_sha = dispatch_sha or os.environ.get("GITHUB_SHA", "").strip()

          if not target_sha:
              raise SystemExit("Unable to determine target release commit SHA.")

          pyproject_text = git_show(target_sha, "pyproject.toml")
          pyproject = tomllib.loads(pyproject_text)
          version = str(pyproject["project"]["version"]).strip()
          if not version:
              raise SystemExit("Project version is empty in pyproject.toml.")
          tag = f"v{version}"

          changelog = git_show(target_sha, "CHANGELOG.md")
          lines = changelog.splitlines()

          header_pattern = re.compile(rf"^##\s+{re.escape(tag)}\b")
          start_index = -1
          for index, line in enumerate(lines):
              if header_pattern.match(line):
                  start_index = index
                  break
          if start_index < 0:
              raise SystemExit(f"CHANGELOG.md missing section header for {tag}.")

          end_index = len(lines)
          for index in range(start_index + 1, len(lines)):
              if lines[index].startswith("## "):
                  end_index = index
                  break

          notes = "\n".join(lines[start_index:end_index]).strip()
          if not notes:
              raise SystemExit(f"Extracted release notes for {tag} are empty.")

          notes_path = Path("release-notes.md")
          notes_path.write_text(notes + "\n", encoding="utf-8")

          output_path = Path(os.environ["GITHUB_OUTPUT"])
          with output_path.open("a", encoding="utf-8") as output:
              output.write(f"target_sha={target_sha}\n")
              output.write(f"version={version}\n")
              output.write(f"tag={tag}\n")
              output.write(f"notes_path={notes_path}\n")
          PY

      - name: Skip if release tag already exists
        id: tag_check
        env:
          TAG: ${{ steps.metadata.outputs.tag }}
        run: |
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag ${TAG} already exists; skipping release creation."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub release (creates tag)
        if: steps.tag_check.outputs.exists != 'true'
        uses: actions/github-script@v7
        env:
          TAG: ${{ steps.metadata.outputs.tag }}
          TARGET_SHA: ${{ steps.metadata.outputs.target_sha }}
          NOTES_PATH: ${{ steps.metadata.outputs.notes_path }}
        with:
          script: |
            const fs = require("fs");
            const tag = process.env.TAG;
            const targetSha = process.env.TARGET_SHA;
            const notesPath = process.env.NOTES_PATH;
            const notes = fs.readFileSync(notesPath, "utf8");

            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag,
              });
              core.notice(`Release ${tag} already exists; skipping.`);
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }

              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                target_commitish: targetSha,
                name: tag,
                body: notes,
                draft: false,
                prerelease: false,
                generate_release_notes: false,
              });
              core.notice(`Created release ${tag} for ${targetSha}.`);
            }

